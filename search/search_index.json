{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SoftwareentwicklungsProzess mit Github","text":"<p>Git erlaubt es allen Entwicklern gleichzeitig Features zu entwickeln. Hierzu existieren diverse Techniken Git zu nutzen. Die bekanntesten hierbei sind:</p> <ul> <li>Git Flow</li> <li>Git(Hub) Flow</li> <li>Trunk-based </li> </ul> <p>Der Github Flow ist eine vereinfachte Version des von der CMI verwendeten Git Flows. F\u00fcr gr\u00f6ssere Organisationen ist dieser Workflow v\u00f6llig ungeeignet, weshalb hier nicht weiter auf diesen eingegangen wird. Infos zu diesem Flow lassen sich direkt bei Github finden.</p>"},{"location":"#terminologie","title":"Terminologie","text":"<p>Die in der CMI verwendete Versionierungs-Software lautet git, bzw. Github in seiner libgit2 Implementation. Git bietet hier viele Funktionalit\u00e4ten. In diesem Dokument werden die Folgenden genutzt:</p>"},{"location":"#branch","title":"Branch","text":"<p>Ein Branch bildet einen Zustand des volls\u00e4ndigen Codes ab und funigert damit quasi als Zeiger auf einen bestimmten Commit  Releases werden stets aus einem Branch heraus erstellt. Ein Branch wird in den folgenden Graphen als Linie dargestellt</p>"},{"location":"#commit","title":"Commit","text":"<p>Ein Commit bildet eine Art Snapshot, der die \u00c4nderungen des Entwicklers enth\u00e4lt. Wenn ein Release gebaut wird, geschieht dies im Regelfall auf dem aktuellsten Commit des Branches. Ein Commit wird in den folgenden Graphen als Knoten dargestellt.</p>"},{"location":"#merge","title":"Merge","text":"<p>Als merge wird der Vorgang bezeichnet, der alle Commits ( und somit alle \u00c4nderungen ) eines Branches in einen anderen Branch \u00fcbernimmt. Im Regelfall passiert das, sobald die Entwicklung eines Youtrack issues abgeschlossen ist. Der initiierende Branch des Merges wird im Anschluss an den Vorgang gel\u00f6scht.</p>"},{"location":"#cherrypick","title":"CherryPick","text":"<p>Der CherryPick erlaubt es, einen beliebigen Commit an der Spitze eines anderen Branches zu duplizieren. W\u00e4hrend der merge es noch erzwingt, dass beide Branches den gleichen Ursprung haben ( zB aus dem gleichen Branch heraus entstanden sind ), muss f\u00fcr einen CherryPick diese Bedingung nicht erf\u00fcllt sein. In der Praxis geht das Brechen dieser Bedingung oft mit MergeKonflikten oder unerw\u00fcnschten Seiteneffekten einher.  Mit der steigenden Anzahl an CherryPicks w\u00e4chst dieses Gefahrenpotential exponentiell.</p>"},{"location":"#git-flow","title":"Git Flow","text":"<p>Der Gitflow ist der \u00e4lteste Workflow und ist zusammen mit Git und Github gewachsen. In der CMI wird dieser Workflow ebenfalls verwendet und kann dann beispielsweise so aussehen:</p> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'master'}} }%%\ngitGraph\n        commit\n        branch develop\n        branch featureA\n        branch featureB\n        branch v.23.0\n        branch release/v23.0.1\n        branch v.23.1\n        branch release/v.23.1.1\n        checkout featureA\n        commit\n        commit\n        checkout featureB\n        commit\n        commit\n        checkout featureA\n        commit\n        checkout featureB\n        commit\n        checkout develop\n        merge featureA tag: \"0.1.0\"\n        checkout featureB\n        commit\n        merge develop\n        commit\n        commit\n        checkout develop\n        merge featureB tag: \"0.1.0\"\n        checkout v.23.0\n        merge develop\n        checkout master\n        merge v.23.0 tag: \"v.23.0.0\"\n        branch featureC\n        merge develop\n        commit id:\"cc1\"\n        commit id: \"cc2\"\n        checkout develop\n        merge featureC\n        checkout release/v23.0.1\n        cherry-pick id: \"cc1\"\n        cherry-pick id: \"cc2\"\n        branch featureD\n        merge develop\n        commit id:\"dc1\"\n        commit id: \"dc2\"\n        checkout develop\n        merge featureD\n        checkout release/v23.0.1\n        cherry-pick id: \"dc1\"\n        cherry-pick id: \"dc2\"\n        checkout release/v.23.1.1\n        cherry-pick id: \"dc1\"\n        cherry-pick id: \"dc2\"\n        checkout v.23.0\n        merge release/v23.0.1\n        checkout master\n        merge v.23.0 tag: \"v.23.0.1\"\n        checkout v.23.1\n        merge release/v.23.1.1\n        checkout master\n        merge release/v.23.1.1 tag: \"v.23.1.1\"\n</code></pre> <p>Die wichtigsten Branches tragen hierbei den Namen master und develop. Den Branch master ( neuerdings auch gerne main ) bezeichnet man ebenfalls als \"Trunk\". So wie bei einem echten Baum wird der Baumstumpf nie entfernt, sollte nicht der ganze Baum entfernt werden.</p> <p>Umkreist werden diese Branches dann von FeatureBranches, Bugfixbranches, Hotfix branches. Zus\u00e4tzlich existieren allerdings viele trunk-\u00e4hnlichen release Branches, die in der CMI dann nach dem Entwicklungsjahr benannt sind ( e.g v.23.X )</p>"},{"location":"#vorteile","title":"Vorteile","text":"<ul> <li>Entwickler k\u00f6nnen vollst\u00e4ndig dezentralisiert arbeiten und m\u00fcssen nur hin und wieder ihren die Trunks in ihre Branches mergen</li> <li>Einfacher Einstieg nach Git f\u00fcr Junior Entwickler</li> <li>Klare Trennung zwischen Entwicklungs und Produktionsst\u00e4nden</li> </ul>"},{"location":"#nachteile","title":"Nachteile","text":"<ul> <li>Die gewaltige Menge an Releases und Patch Branches macht es fast unm\u00f6glich noch eine \u00dcbersicht zu behalten</li> <li>Cherrypicks in die ReleaseBranches werden ben\u00f6tigt, wodurch unerw\u00fcnschte Seiteneffekte durch picken in der falschen Reihenfolge oder Merge Konfltikte passieren</li> <li>Merge Konflikte sind gross und Komplex und ben\u00f6tigen des \u00d6fteren einen \"Git Profi\", der diese dann l\u00f6st</li> <li>Sehr tr\u00e4ge ReleaseFrequenz</li> </ul>"},{"location":"#nachteile-cmi","title":"Nachteile ( CMI )","text":"<ul> <li>Features m\u00fcssen gebackported werden und erzeugen die Gefahr unerw\u00fcnschter Seiteneffekte</li> <li>FeatureBackporting ist oft durch die ver\u00e4nderte Codebasis nicht m\u00f6glich und ben\u00f6tigt dadurch ver\u00e4nderten Code zwischen dem Trunk, der auf der KV getestet wird,   und dem Release Stand, der Schlussendlich an die Kunden verteilt wird.</li> <li>Features werden vor der Freigabe eines Releases kaum getestet ( h\u00e4ngt allerdings nur indirekt mit dem ReleaseModell zusammen )</li> <li>Viele verschiedene ReleaseSt\u00e4nde ( Projektreleases !), obwohl der GitFlow traditionell nur einen einzigen Release Branch vorsieht</li> <li>Dll patches nehmen selbst den freigegebenen St\u00e4nden ihre Homogenit\u00e4t</li> </ul>"},{"location":"#trunkbased-development","title":"Trunkbased Development","text":"<p>Eine Alternative ist hierzu das sog. TrunkBasedDevelopment. Der grosse Vorteil dieser Methodik liegt darin, dass deutlich weniger Branches existieren. Dadruch werden weniger Cherrypicks und Tests \u00e4lterer St\u00e4nde ben\u00f6tigt. Als Ergebnis erzeugt dies mehr Zeit f\u00fcr die tats\u00e4chliche Entwicklung des Produkts.</p> <p>Dieses Verahren wird in der CMI bereits f\u00fcr die meisten Microservices ( STS, WebDav, Push, etc.) verwendet. Weiterhin wurde zB das GWR3.0 Projekt nach diesem Stil erfolgreich entwickelt.</p> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'master'}} }%%\ngitGraph\n        commit\n        branch Task1\n        branch Task2\n        checkout Task1\n        commit\n        commit\n\n        checkout Task2\n        commit\n        checkout master\n        merge Task2 id: \"23.4.0\" type: HIGHLIGHT\n        checkout Task1\n        merge master\n        commit\n        checkout master\n        merge Task1 id: \"23.5.0\" type: HIGHLIGHT\n        branch featureA\n        branch A/Task1\n        branch A/Task2\n        checkout featureA\n        commit id: \"initial\"\n        checkout A/Task1\n        commit\n        commit\n        checkout A/Task2\n        commit\n        checkout featureA\n        merge A/Task2\n        checkout A/Task1\n        merge featureA\n        checkout master\n        branch Task3\n        commit\n        checkout master\n        branch bugfix1\n        commit\n        checkout master\n        merge bugfix1 id: \"23.5.1\"\n        merge Task3 id: \"23.6.0\" type: HIGHLIGHT\n        checkout featureA\n        merge master\n        checkout A/Task1\n        merge featureA\n        commit\n        checkout featureA\n        merge A/Task1\n        checkout master\n        merge featureA\n</code></pre>"},{"location":"#vorteile_1","title":"Vorteile","text":"<ul> <li>Immens weniger Wartungsaufwand durch weniger Branches </li> <li>Sehr gute Integration in CI/CD Workflows erlaubt es zB dem PM ein Feature w\u00f6hrend der Entwicklung tats\u00e4chlich \"wachsen zu sehen\"</li> <li>Schnellere Releases</li> <li>Nur selten Konflikte w\u00e4hrend des Merges</li> <li>Keine \"Feature Freezes\" ben\u00f6tigt</li> <li>Entwickler eines Features erhalten etwas mehr Freiheiten w\u00e4hrend der Entwicklung</li> <li>Entwickler m\u00fcssen weniger Zeit f\u00fcr die Reproduktion von Bugs aufwenden</li> </ul>"},{"location":"#nachteile_1","title":"Nachteile","text":"<ul> <li>In der Realit\u00e4t nur zusammen mit CI/CD hilfreich ( Ist im CMI System bereits vorhanden )</li> <li>Langlebige Feature Branches m\u00fcssen ca alle 1-2 Wochen gerebased werden um merge Konflikte zu vermeiden</li> <li>Entwickler eines Features erhalten etwas mehr Freiheiten w\u00e4hrend der Entwicklung, wodurch das PM   dementsprechend weniger Kontrolle \u00fcber die Features eines Releases hat</li> </ul>"},{"location":"#nachteile-cmi_1","title":"Nachteile ( CMI )","text":"<ul> <li>Neues Versionierungsmodell muss erst kommuniziert werden</li> <li>M\u00f6glicherweise fehlt bei manchen Kunden die Akzeptanz f\u00fcr dieses Model.</li> </ul>"}]}
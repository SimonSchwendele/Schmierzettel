{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SoftwareentwicklungsProzess mit Github","text":"<p>Git erlaubt es allen Entwicklern gleichzeitig Features zu entwickeln. Hierzu existieren diverse Techniken Git zu nutzen. Die bekanntesten hierbei sind:</p> <ul> <li>Git Flow</li> <li>Git(Hub) Flow</li> <li>Trunk-based </li> </ul> <p>Der Github Flow ist eine vereinfachte Version des von der CMI verwendeten Git Flows. F\u00fcr gr\u00f6ssere Organisationen ist dieser Workflow v\u00f6llig ungeeignet, weshalb dieser Aufschrieb nicht weiter darauf eingehen wird.</p>"},{"location":"#git-flow","title":"Git Flow","text":"<p>Der Gitflow ist der \u00e4lteste Workflow und ist zusammen mit Git und Github gewachsen. In der CMI wird dieser Workflow ebenfalls verwendet und sieht hierbei ungef\u00e4hr so aus:</p> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'master'}} }%%\ngitGraph\n        commit\n        branch develop\n        branch featureA\n        branch featureB\n        branch v.23.0\n        branch release/v23.0.1\n        branch v.23.1\n        branch release/v.23.1.1\n        checkout featureA\n        commit\n        commit\n        checkout featureB\n        commit\n        commit\n        checkout featureA\n        commit\n        checkout featureB\n        commit\n        checkout develop\n        merge featureA tag: \"0.1.0\"\n        checkout featureB\n        commit\n        merge develop\n        commit\n        commit\n        checkout develop\n        merge featureB tag: \"0.1.0\"\n        checkout v.23.0\n        merge develop\n        checkout master\n        merge v.23.0 tag: \"v.23.0.0\"\n        branch featureC\n        merge develop\n        commit id:\"cc1\"\n        commit id: \"cc2\"\n        checkout develop\n        merge featureC\n        checkout release/v23.0.1\n        cherry-pick id: \"cc1\"\n        cherry-pick id: \"cc2\"\n        branch featureD\n        merge develop\n        commit id:\"dc1\"\n        commit id: \"dc2\"\n        checkout develop\n        merge featureD\n        checkout release/v23.0.1\n        cherry-pick id: \"dc1\"\n        cherry-pick id: \"dc2\"\n        checkout release/v.23.1.1\n        cherry-pick id: \"dc1\"\n        cherry-pick id: \"dc2\"\n        checkout v.23.0\n        merge release/v23.0.1\n        checkout master\n        merge v.23.0 tag: \"v.23.0.1\"\n        checkout v.23.1\n        merge release/v.23.1.1\n        checkout master\n        merge release/v.23.1.1 tag: \"v.23.1.1\"\n</code></pre> <p>Der Grundbaustein sind hier der trunks master und develop.  Umkreist werden diese dann von FeatureBranches, Bugfixbranches, Hotfix branches.</p> <p>Zus\u00e4tzlich existieren dann allerdings viele trunk-\u00e4hnlichen release branches, die in der CMI dann nach dem Entwicklungsjahr benannt sind ( e.g v.23.X )</p>"},{"location":"#vorteile","title":"Vorteile","text":"<ul> <li>Entwicklker k\u00f6nnen vollst\u00e4ndig dezentralisiert arbeiten und m\u00fcssen nur hin und wieder ihren jeweiligen Trunk mergen</li> <li>Einfacher Einstieg nach Git</li> <li>Klare Trennung zwischen Entwicklungs und Produktionsst\u00e4nden</li> </ul>"},{"location":"#nachteile","title":"Nachteile","text":"<ul> <li>Die gewaltige Menge an Releases und Patch branches macht es fast unm\u00f6glich noch eine \u00dcbersicht zu behalten</li> <li>Cherrypicks in die ReleaseBranches werden ben\u00f6tigt, wodurch unerw\u00fcnschte Seiteneffekte durch picken in der falschen Reihenfolge oder Merge Konfltikte passieren</li> <li>Merge Konflikte sind gross und Komplex und ben\u00f6tigen des \u00d6fteren einen \"Git Profi\", der diese dann l\u00f6st</li> <li>Sehr tr\u00e4ge ReleaseFrequenz</li> </ul>"},{"location":"#nachteile-cmi","title":"Nachteile ( CMI )","text":"<ul> <li>Features m\u00fcssen gebackported werden und erzeugen die Gefahr unerw\u00fcnschter Seiteneffekte</li> <li>FeatureBackporting oft nicht m\u00f6glich durch eine ver\u00e4nderte Codebasis und ben\u00f6tigt dadurch ver\u00e4nderten Code zwischen KV und Kundenstand</li> <li>Features werden vor der Freigabe eines Releases kaum getestet</li> <li>Viele verschiedene ReleaseSt\u00e4nde ( Projektreleases !), obwohl der GitFlow traditionell nur einen release branch vorsieht</li> <li>Dll patches nehmen selbst den freigegebenen St\u00e4nden ihre Homogenit\u00e4t</li> </ul>"},{"location":"#trunkbased-development","title":"Trunkbased Development","text":"<p>Eine alternative ist hierzu das sog. TrunkBasedDevelopment. Der grosse Vorteil dieser Methodik liegt darin, dass deutlich weniger Branches existieren. Dadruch werden weniger cherrypicks und Tests \u00e4lterer St\u00e4nde ben\u00f6tigt und erlauben mehr Zeit f\u00fcr die tats\u00e4chliche Entwicklung des Produkts.</p> <p>Dieses Verahren wird in der CMI bereits f\u00fcr die meisten Microservices ( STS, WebDav, Push, etc.) verwendet. Weiterhin wurde zB das GWR3.0 Projekt nach diesem Stil erfolgreich entwickelt.</p> <pre><code>%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchName': 'master'}} }%%\ngitGraph\n        commit\n        branch Task1\n        branch Task2\n        checkout Task1\n        commit\n        commit\n\n        checkout Task2\n        commit\n        checkout master\n        merge Task2 id: \"23.4.0\" type: HIGHLIGHT\n        checkout Task1\n        merge master\n        commit\n        checkout master\n        merge Task1 id: \"23.5.0\" type: HIGHLIGHT\n        branch featureA\n        branch A/Task1\n        branch A/Task2\n        checkout featureA\n        commit id: \"initial\"\n        checkout A/Task1\n        commit\n        commit\n        checkout A/Task2\n        commit\n        checkout featureA\n        merge A/Task2\n        checkout A/Task1\n        merge featureA\n        checkout master\n        branch Task3\n        commit\n        checkout master\n        branch bugfix1\n        commit\n        checkout master\n        merge bugfix1 id: \"23.5.1\"\n        merge Task3 id: \"23.6.0\" type: HIGHLIGHT\n        checkout featureA\n        merge master\n        checkout A/Task1\n        merge featureA\n        commit\n        checkout featureA\n        merge A/Task1\n        checkout master\n        merge featureA\n</code></pre>"},{"location":"#vorteile_1","title":"Vorteile","text":"<ul> <li>Immens weniger Wartungsaufwand durch weniger Branches </li> <li>Sehr gute Integration in CI/CD Workflows</li> <li>Schnellere Releases</li> <li>Nur selten merge Konflikte</li> <li>Keine \"Feature Freezes\" ben\u00f6tigt</li> <li>Entwicklern eines Features erhalten etwas mehr Freiheiten w\u00e4hrend der Entwicklung</li> </ul>"},{"location":"#nachteile_1","title":"Nachteile","text":"<ul> <li>In der Realit\u00e4t nur zusammen mit CI/CD hilfreich ( Ist im CMI System bereits vorhanden )</li> <li>Langlebige Feature Branches m\u00fcssen ca alle 1-2 Wochen gerebased werden um merge Konflikte zu vermeiden</li> <li>Entwicklern eines Features erhalten etwas mehr Freiheiten w\u00e4hrend der Entwicklung</li> </ul>"},{"location":"#nachteile-cmi_1","title":"Nachteile ( CMI )","text":"<ul> <li>Neues Versionierungsmodell muss erst kommuniziert werdend</li> </ul>"}]}